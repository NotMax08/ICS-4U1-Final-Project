import greenfoot.*;
import java.util.ArrayList;
/**
 * The Player class manages controls related to the Player character
 * Controls such as movement and abilities
 * 
 * Images generated by Leonardo.ai
 * 
 * @author Robin and Paul, assisted by Claude
 */
public class Player extends ScrollingActor {
    // Movement constants
    private double velocityX = 0;
    private double velocityY = 0;
    private static final double GRAVITY = 1;
    private static final double JUMP_STRENGTH = -25;
    private static final double MOVE_SPEED = 7.2;
    private static final double MAX_FALL_SPEED = 24;

    // Character constants
    private static final int ANIMATION_SPEED = 4; 
    private static final int FALL_DAMAGE_THRESHOLD = 60; // Acts of falling before stun
    private static final int STUN_DURATION = 30; // Acts to remain stunned
    private static final int BASIC_ATTACK_COOLDOWN = 25;
    private static final int BASIC_ATTACK_DAMAGE = 7;
    private static final int STARTING_HEALTH_POINTS= 3;
    private static final int ABSOLUTE_MAX_HEALTH_POINTS = 6;
    
    private static int currentHealth;
    private static int maxHealth;

    // Character states 
    private boolean onGround = false;
    private boolean inDoor = false;
    private boolean inInteractive = false;
    private boolean direction = true; // false = left, true = right
    private boolean isStunned = false;
    private boolean isAttacking = false;
    private boolean isTakingDamage = false;

    // Counters - using Counter class
    private Counter fallCounter;
    private Counter stunCounter;
    private Counter runningAnimCounter;
    private Counter jumpingAnimCounter;
    private Counter fallingAnimCounter;
    private Counter frameCounter;
    private Counter abilityCooldownCounter;

    // Player image constants
    private static int P_WIDTH = 50;
    private static int P_HEIGHT = 100;

    // Standing Frames
    private GreenfootImage standingRight = new GreenfootImage("standingRight.png");
    private GreenfootImage standingLeft = new GreenfootImage("standingLeft.png");
    // Running Right
    private GreenfootImage runningR1 = new GreenfootImage("running1.png");
    private GreenfootImage runningR2 = new GreenfootImage("running2.png");
    private GreenfootImage runningR3 = new GreenfootImage("running3.png");
    private GreenfootImage runningR4 = new GreenfootImage("running4.png");
    private GreenfootImage[] runningRight;
    // Running Left
    private GreenfootImage runningL1;
    private GreenfootImage runningL2;
    private GreenfootImage runningL3;
    private GreenfootImage runningL4;
    private GreenfootImage[] runningLeft;
    // Jumping Right
    private GreenfootImage jumpR1 = new GreenfootImage("jump1.png");
    private GreenfootImage jumpR2 = new GreenfootImage("jump2.png");
    private GreenfootImage[] jumpingRight;
    // Jumping Left
    private GreenfootImage jumpL1;
    private GreenfootImage jumpL2;
    private GreenfootImage[] jumpingLeft;
    // Falling Right
    private GreenfootImage fallR1 = new GreenfootImage("fall1.png");
    private GreenfootImage fallR2 = new GreenfootImage("fall2.png");
    private GreenfootImage[] fallingRight;
    // Falling Left
    private GreenfootImage fallL1;
    private GreenfootImage fallL2;
    private GreenfootImage[] fallingLeft;
    
    //Item data
    public int[][] itemData;

    public Player(Camera camera) {
        super(camera);

        this.maxHealth = STARTING_HEALTH_POINTS;
        this.currentHealth = maxHealth;
        
        // Initialize Counters
        fallCounter = new Counter();
        stunCounter = new Counter(STUN_DURATION);
        runningAnimCounter = new Counter(ANIMATION_SPEED);
        jumpingAnimCounter = new Counter(ANIMATION_SPEED * 2);
        fallingAnimCounter = new Counter(ANIMATION_SPEED * 2);
        frameCounter = new Counter();
        abilityCooldownCounter = new Counter(BASIC_ATTACK_COOLDOWN);

        // Initialize images
        scaleImages(); 
        createMirroredImages();
        setupAnimationArrays();
        setImage(standingRight);
    }

    public void act() {
        //checkStunned();
        checkAbilityCooldown();
        handleInput();
        applyGravity();
        checkFall();
        checkDoor();
        moveHorizontal();
        moveVertical();
        //System.out.println(getWorldX() + ", " + getWorldY());
    }
    
    private void checkStunned(){
        // If stunned, count down stun timer and don't allow movement
        if (isStunned) {
            stunCounter.decrement();
            if (stunCounter.isZero()) {
                isStunned = false;
            }
            applyGravity();
            moveVertical(); // Still affected by gravity while stunned
            return; // Skip normal input handling
        }
    }
    
    private void checkAbilityCooldown(){
        // Count down attack cooldown
        if(!abilityCooldownCounter.isZero()){
            abilityCooldownCounter.decrement();
            if(abilityCooldownCounter.isZero()){
                isAttacking = false;
            }
        }
    }

    private void scaleImages(){
        // Character Animation
        // standing images
        standingRight.scale(P_WIDTH,P_HEIGHT);
        standingLeft.scale(P_WIDTH,P_HEIGHT);
        // moving images
        runningR1.scale(P_WIDTH + 30,P_HEIGHT - 20); 
        runningR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
        runningR3.scale(P_WIDTH + 30,P_HEIGHT - 20);
        runningR4.scale(P_WIDTH + 30,P_HEIGHT - 20);
        jumpR1.scale(P_WIDTH + 30,P_HEIGHT - 20);
        jumpR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
        fallR1.scale(P_WIDTH + 30,P_HEIGHT - 20);
        fallR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
    }

    private void createMirroredImages(){
        // Create mirrored versions for left-facing animation
        runningL1 = new GreenfootImage(runningR1);
        runningL1.mirrorHorizontally();

        runningL2 = new GreenfootImage(runningR2);
        runningL2.mirrorHorizontally();

        runningL3 = new GreenfootImage(runningR3);
        runningL3.mirrorHorizontally();

        runningL4 = new GreenfootImage(runningR4);
        runningL4.mirrorHorizontally();

        jumpL1 = new GreenfootImage(jumpR1);
        jumpL1.mirrorHorizontally();

        jumpL2 = new GreenfootImage(jumpR2);
        jumpL2.mirrorHorizontally();

        fallL1 = new GreenfootImage(fallR1);
        fallL1.mirrorHorizontally();

        fallL2 = new GreenfootImage(fallR2);
        fallL2.mirrorHorizontally();
    }

    private void setupAnimationArrays() {
        // Create animation arrays for easy cycling
        runningRight = new GreenfootImage[]{runningR1, runningR2, runningR3, runningR4};
        runningLeft = new GreenfootImage[]{runningL1, runningL2, runningL3, runningL4};
        jumpingRight = new GreenfootImage[]{jumpR1, jumpR2};
        jumpingLeft = new GreenfootImage[]{jumpL1, jumpL2};
        fallingRight = new GreenfootImage[]{fallR1, fallR2};
        fallingLeft = new GreenfootImage[]{fallL1, fallL2};
    }

    private void handleInput() {
        handleMovement();
        handleAbility();
    }

    private void handleMovement(){
        // check if in air
        if(!onGround){
            // reset ground counter when in the air
            runningAnimCounter.reset();
            if(velocityY < 0){
                // reset falling counter when jumping
                fallingAnimCounter.reset();
                animateJumping();
            }else{
                // reset jumping counter when falling
                jumpingAnimCounter.reset();
                animateFalling();
            }

            // Moving in the air
            if (Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
                direction = false;
                velocityX = -MOVE_SPEED * 0.85; // Slightly reduced horizontal movement speed while in the air
            } else if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right")) {
                direction = true;
                velocityX = MOVE_SPEED * 0.85;
            } else {
                velocityX = 0;
            }
        }else{
            // reset air counters when on ground
            jumpingAnimCounter.reset();
            fallingAnimCounter.reset();
            // Normal ground movement
            if (Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
                direction = false;
                velocityX = -MOVE_SPEED;
                animateRunning();
            } else if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right")) {
                direction = true;
                velocityX = MOVE_SPEED;
                animateRunning();
            } else {
                //standing still
                velocityX = 0;
                frameCounter.reset();
                runningAnimCounter.reset();
                if(velocityY == 0){
                    if(!direction){
                        setImage(standingLeft);
                    }else{
                        setImage(standingRight);
                    }
                }
            }
        }

        // Jump
        if ((Greenfoot.isKeyDown("space") || Greenfoot.isKeyDown("w")) && onGround) {
            velocityY = JUMP_STRENGTH;
            onGround = false;
            // reset frames
            frameCounter.reset();
            jumpingAnimCounter.reset();
        }

        // Fall faster
        if ((Greenfoot.isKeyDown("s") || Greenfoot.isKeyDown("down") && !onGround)){
            velocityY += GRAVITY;
        }
    }

    private void handleAbility(){
        if(abilityCooldownCounter.isZero()){
            if(Greenfoot.isKeyDown("j")){
                basicAttack();
            }else if(Greenfoot.isKeyDown("k") && GameWorld.magicUnlocked){
                magicAttack();
            }
        }
    }

    private void basicAttack(){
        isAttacking = true;
        abilityCooldownCounter.set(BASIC_ATTACK_COOLDOWN);

        // slash animation
        SlashAnimation slash = new SlashAnimation(6,2);

        // changes depending on which direction the player is facing
        int slashOffsetX = direction ? 30: -30; 
        int slashOffsetY = 0; // same height as player

        // add to world
        GameWorld world = (GameWorld) getWorld();
        if(world != null){
            // World position
            int slashWorldX = worldX + slashOffsetX;
            int slashWorldY = worldY + slashOffsetY;
            // Screen position
            int slashScreenX = camera.worldToScreenX(slashWorldX);
            int slashScreenY = camera.worldToScreenY(slashWorldY);

            world.addObject(slash, slashScreenX, slashScreenY);

            // Flip image if facing left
            if(!direction){
                GreenfootImage slashImg = slash.getImage();
                slashImg.mirrorHorizontally();
                slash.setImage(slashImg);
            }

            checkAttackHit(slashWorldX, slashWorldY, BASIC_ATTACK_DAMAGE);
        }
    }

    private void checkAttackHit(int attackX, int attackY, int damage){
        GameWorld world = (GameWorld) getWorld();
        if(world == null) return;
        
        // 
        int attackScreenX = camera.worldToScreenX(attackX);
        int attackScreenY = camera.worldToScreenY(attackY);
        
        ArrayList<BaseEnemy> enemies = new ArrayList<BaseEnemy>(world.getObjectsAt(
            attackScreenX,
            attackScreenY,
            BaseEnemy.class
        ));
        
        for(BaseEnemy enemy : enemies){
            enemy.takeDamage(damage);
        }
            
    }

    private void magicAttack(){
        
    }

    private void animateRunning(){
        runningAnimCounter.increment();

        // Change frame based on animation speed
        if (runningAnimCounter.isComplete()) {
            runningAnimCounter.reset();
            frameCounter.increment();

            // Loop back to first frame (4 total)
            if(frameCounter.greaterThan(3)){
                frameCounter.reset();
            }
        }

        // Set the appropriate frame based on direction
        if (direction) {
            setImage(runningRight[frameCounter.getCount()]);
        } else {
            setImage(runningLeft[frameCounter.getCount()]);
        }
    }

    private void animateJumping(){
        jumpingAnimCounter.increment();

        // Change frame based on animation speed
        if(jumpingAnimCounter.isComplete()) {
            jumpingAnimCounter.reset();
            frameCounter.increment();
        }
        // Loop back to first frame (4 total)
        if(frameCounter.greaterThan(1)){
            frameCounter.reset();
        }
        // Set frame based on direction
        if(direction){
            setImage(jumpingRight[frameCounter.getCount()]);
        }else{
            setImage(jumpingLeft[frameCounter.getCount()]);
        }
    }

    private void animateFalling(){
        fallingAnimCounter.increment();

        // Change frame based on animation speed
        if(fallingAnimCounter.isComplete()) {
            fallingAnimCounter.reset();
            frameCounter.increment();
        }

        // Loop back to first frame (2 total)
        if(frameCounter.greaterThan(1)){
            frameCounter.reset();
        }

        // Set frame based on direction
        if(direction){
            setImage(fallingRight[frameCounter.getCount()]);
        }else{
            setImage(fallingLeft[frameCounter.getCount()]);
        }
    }

    private void applyGravity() {
        velocityY += GRAVITY;
        if (velocityY > MAX_FALL_SPEED) {
            velocityY = MAX_FALL_SPEED;
        }
    }

    private void checkFall(){
        if (!onGround && velocityY > 0) {
            // Player is falling - increment fall counter
            fallCounter.increment();
        } else if (!fallCounter.isZero()) {
            // Player just landed - check if fall was long enough to cause stun
            if (fallCounter.greaterThan(FALL_DAMAGE_THRESHOLD)) {
                isStunned = true;
                stunCounter.set(STUN_DURATION);

                // Visual feedback - flash the player red
                GreenfootImage img = getImage();
                img.setTransparency(150); // Make slightly transparent
            }

            // Reset fall counter
            fallCounter.reset();
        }
    }

    private void moveHorizontal() {
        // Try to move horizontally
        int targetX = (int)(worldX + velocityX);

        if (!isSolidAtPosition(targetX, worldY)) {
            // Path is clear, move freely
            worldX = targetX;
        } else {
            // Hit a wall, slide as close as possible
            int step = velocityX > 0 ? 1 : -1;
            while (!isSolidAtPosition(worldX + step, worldY)) {
                worldX += step;
            }
            velocityX = 0;
        }
    }

    private void moveVertical() {
        // Try to move vertically
        int targetY = (int)(worldY + velocityY);

        if (!isSolidAtPosition(worldX, targetY)) {
            // Path is clear, move freely
            worldY = targetY;
            onGround = false;
        } else {
            // Hit floor or ceiling, slide as close as possible
            int step = velocityY > 0 ? 1 : -1;
            while (!isSolidAtPosition(worldX, worldY + step)) {
                worldY += step;
            }

            // Check if we landed on ground
            if (velocityY > 0) {
                onGround = true;
            }
            velocityY = 0;
        }
    }
    
    public void takeDamage(int dmg){
        currentHealth = Math.max(0, currentHealth - dmg);
    }
    
    public void heal(int hp){
        currentHealth = Math.min(maxHealth, currentHealth + hp);
    }
    
    public void increaseMaxHealth(int hp){
        maxHealth = Math.min(maxHealth + hp, ABSOLUTE_MAX_HEALTH_POINTS);
        currentHealth = maxHealth;
    }

    /**
     * @author Paul
     */
    private void checkDoor(){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return;
        if (isDoorAtPosition(worldX, worldY)) {
            inDoor = true;
            if( getWorld() instanceof RoomOne){
                Greenfoot.setWorld(new RoomTwo());
            }else if(getWorld() instanceof RoomTwo){
                Greenfoot.setWorld(new RoomThree());
            }
        } else {
            inDoor = false;
        }
    }
    private void checkInteractive(){
        if (isDoorAtPosition(worldX, worldY)) {
            inInteractive = true;
            
        } else {
            inInteractive = false;
        }
    }
    /**
     * Check if the player's hitbox at this position would collide with solid tiles
     * @author Paul assisted by Claude
     */ 
    private boolean isSolidAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;
    
        // Check all edges: corners + middle points for better collision
        return checkTileAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left corner
               checkTileAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right corner
               checkTileAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left corner
               checkTileAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right corner
               checkTileAt(posX, posY - halfHeight + 1) ||                  // Top-middle (HEAD)
               checkTileAt(posX, posY + halfHeight - 1) ||                  // Bottom-middle (FEET)
               checkTileAt(posX - halfWidth + 1, posY) ||                   // Left-middle
               checkTileAt(posX + halfWidth - 1, posY);                     // Right-middle
    }

    /**
     * @author Paul
     */
    private boolean isDoorAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;

        // Check four corners and center
        return checkDoorAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left
        checkDoorAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right
        checkDoorAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left
        checkDoorAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right
        checkDoorAt(posX, posY);                                      // Center
    }
    /**
     * @author Paul
     */
    private boolean isInteractiveAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;

        // Check four corners and center
        return checkInteractiveAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left
        checkInteractiveAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right
        checkInteractiveAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left
        checkInteractiveAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right
        checkInteractiveAt(posX, posY);                                      // Center
    }
    /**
     *  Check if a specific world coordinate contains a solid tile
     *  @author Paul
     */
    private boolean checkTileAt(int worldX, int worldY) {
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        // Type 1 = walls, Type 2 = platforms, Type 3 = doors
        return tileType == 1 || tileType == 2 ;
    }

    /**
     * @author Paul
     */
    private boolean checkDoorAt(int worldX, int worldY){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        return tileType == 3 ;
    }
    /**
     * @author Paul
     */
    private boolean checkInteractiveAt(int worldX, int worldY){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        return tileType == 5 ;
    }
    
    // Getters
    public boolean isOnGround() {
        return onGround;
    }
    public int getHealth(){
        return currentHealth;
    }
    public int getMaxHealth(){
        return maxHealth;
    }
    public int getAbsMaxHealth(){
        return ABSOLUTE_MAX_HEALTH_POINTS;
    }
    public boolean isInDoor(){
        return inDoor;
    }
    public boolean isInInteractive(){
        return inInteractive;
    }
    public double getVelocityX() {
        return velocityX;
    }
    public double getVelocityY() {
        return velocityY;
    }
    public int getAbilityCooldown(){
        return abilityCooldownCounter.getCount();
    }
    public int[][] getItemData(){
        return itemData;
    }
}