import greenfoot.*;
import java.util.ArrayList;
/**
 * The Player class manages controls related to the Player character
 * Controls such as movement and abilities
 * 
 * Images generated by Leonardo.ai
 * 
 * @author Julian, Robin, and Paul, assisted by Claude
 */
public class Player extends ScrollingActor {
    // Movement constants
    private double velocityX = 0;
    private double velocityY = 0;
    private static final double GRAVITY = 1;
    private static final double JUMP_STRENGTH = -25;
    private static final double MOVE_SPEED = 7.2;
    private static final double MAX_FALL_SPEED = 24;

    // Character constants
    private static final int ANIMATION_SPEED = 4; 
    //private static final int FALL_DAMAGE_THRESHOLD = 60; // Acts of falling before stun
    //private static final int STUN_DURATION = 30; // Acts to remain stunned
    private static final int BASIC_ATTACK_COOLDOWN = 25;
    private static final int BASIC_ATTACK_DAMAGE = 7;
    private static final int HITBOX_EXPANSION = 30; // Extra pixels to make hitting easier
    private static final int MAGIC_ATTACK_COOLDOWN = 80;
    private static final int MAGIC_ATTACK_DAMAGE = 15;
    private static final int MAGIC_ATTACK_RADIUS = 70;
    private static final int STARTING_HEALTH_POINTS= 5;
    private static final int ABSOLUTE_MAX_HEALTH_POINTS = 10;
    private static final int MAX_MANA = 8;
    private static final int HEALING_SPEED = 60;

    private int maxHealth = STARTING_HEALTH_POINTS;
    private int currentHealth = maxHealth;
    private int currentMana = 0;
    private int currency = 0;

    // Character states 
    private boolean onGround = false;
    private boolean inDoor = false;
    private boolean inInteractive = false;
    private boolean direction = true; // false = left, true = right
    private boolean isStunned = false;
    private boolean isAttacking = false;
    private boolean isTakingDamage = false;
    private static boolean attackUpgraded = false;
    private static boolean magicUnlocked = true;
    private boolean isHealing = false;

    // Sound Manager
    private SoundManager soundManager;

    // Counters - using Counter class
    private Counter fallCounter;
    private Counter stunCounter;
    private Counter runningAnimCounter;
    private Counter jumpingAnimCounter;
    private Counter fallingAnimCounter;
    private Counter frameCounter;
    private Counter abilityCooldownCounter;
    private Counter healCounter;

    // Player image constants
    private static int P_WIDTH = 50;
    private static int P_HEIGHT = 100;

    // Standing Frames
    private GreenfootImage standingRight = new GreenfootImage("standingRight.png");
    private GreenfootImage standingLeft = new GreenfootImage("standingLeft.png");
    // Running Right
    private GreenfootImage runningR1 = new GreenfootImage("running1.png");
    private GreenfootImage runningR2 = new GreenfootImage("running2.png");
    private GreenfootImage runningR3 = new GreenfootImage("running3.png");
    private GreenfootImage runningR4 = new GreenfootImage("running4.png");
    private GreenfootImage[] runningRight;
    // Running Left
    private GreenfootImage runningL1;
    private GreenfootImage runningL2;
    private GreenfootImage runningL3;
    private GreenfootImage runningL4;
    private GreenfootImage[] runningLeft;
    // Jumping Right
    private GreenfootImage jumpR1 = new GreenfootImage("jump1.png");
    private GreenfootImage jumpR2 = new GreenfootImage("jump2.png");
    private GreenfootImage[] jumpingRight;
    // Jumping Left
    private GreenfootImage jumpL1;
    private GreenfootImage jumpL2;
    private GreenfootImage[] jumpingLeft;
    // Falling Right
    private GreenfootImage fallR1 = new GreenfootImage("fall1.png");
    private GreenfootImage fallR2 = new GreenfootImage("fall2.png");
    private GreenfootImage[] fallingRight;
    // Falling Left
    private GreenfootImage fallL1;
    private GreenfootImage fallL2;
    private GreenfootImage[] fallingLeft;

    //Item data
    public int[] itemCount = new int[4];

    /**
     * Main constructor for player
     * 
     * @param Camera    tracks the player 
     */
    public Player(Camera camera) {
        super(camera);

        // Initialize Sound Manager
        soundManager = SoundManager.getInstance();

        // Initialize Counters
        runningAnimCounter = new Counter(ANIMATION_SPEED);
        jumpingAnimCounter = new Counter(ANIMATION_SPEED * 2);
        fallingAnimCounter = new Counter(ANIMATION_SPEED * 2);
        frameCounter = new Counter();
        abilityCooldownCounter = new Counter(BASIC_ATTACK_COOLDOWN);
        healCounter = new Counter();

        // Initialize images
        scaleImages(); 
        createMirroredImages();
        setupAnimationArrays();
        setImage(standingRight);
        
        soundManager.loadSound("slash_enemy", "Slash.mp3", 10);

    }

    /**
     * Main act method 
     * 
     */
    public void act() {
        //checkStunned();
        checkHealth();
        checkAbilityCooldown();
        checkHealing();
        handleInput();
        applyGravity();
        //checkFall();
        checkDoor();
        moveHorizontal();
        moveVertical();
        countItems();
        //System.out.println(getWorldX() + ", " + getWorldY());
    }

    public void countItems(){

    }

    /**
     * changes the count of a specific item in index
     * @param index -> index in the array 0 - 3
     * @param amount the amount to add or subtract
     * @author Julian
     */
    public void updateItemCount(int index, int amount) {
        if (index >= 0 && index < itemCount.length) {
            itemCount[index] += amount;

            //prevents negative items
            if (itemCount[index] < 0) itemCount[index] = 0;
        }
    }

    private void checkHealth(){
        if(currentHealth <= 0){
            endScreen();
        }
    }

    private void endScreen(){
        // Reset stats for next game
        maxHealth = STARTING_HEALTH_POINTS;
        currentHealth = STARTING_HEALTH_POINTS;
        currentMana = 0;

        Greenfoot.setWorld(new DeathScreen());
    }

    private void checkAbilityCooldown(){
        // Count down attack cooldown
        if(!abilityCooldownCounter.isZero()){
            abilityCooldownCounter.decrement();
            if(abilityCooldownCounter.isZero()){
                isAttacking = false;
            }
        }
    }

    private void checkHealing(){
        if(isHealing){
            healCounter.increment();
            if(healCounter.getCount() >= HEALING_SPEED){
                heal(1);
                soundManager.playSound("heal");
                currentMana -= 4;
                isHealing = false;
                healCounter.reset();
            }
        }
    }

    private void scaleImages(){
        // Character Animation
        // standing images
        standingRight.scale(P_WIDTH,P_HEIGHT);
        standingLeft.scale(P_WIDTH,P_HEIGHT);
        // moving images
        runningR1.scale(P_WIDTH + 30,P_HEIGHT - 20); 
        runningR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
        runningR3.scale(P_WIDTH + 30,P_HEIGHT - 20);
        runningR4.scale(P_WIDTH + 30,P_HEIGHT - 20);
        jumpR1.scale(P_WIDTH + 30,P_HEIGHT - 20);
        jumpR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
        fallR1.scale(P_WIDTH + 30,P_HEIGHT - 20);
        fallR2.scale(P_WIDTH + 30,P_HEIGHT - 20);
    }

    private void createMirroredImages(){
        // Create mirrored versions for left-facing animation
        runningL1 = new GreenfootImage(runningR1);
        runningL1.mirrorHorizontally();

        runningL2 = new GreenfootImage(runningR2);
        runningL2.mirrorHorizontally();

        runningL3 = new GreenfootImage(runningR3);
        runningL3.mirrorHorizontally();

        runningL4 = new GreenfootImage(runningR4);
        runningL4.mirrorHorizontally();

        jumpL1 = new GreenfootImage(jumpR1);
        jumpL1.mirrorHorizontally();

        jumpL2 = new GreenfootImage(jumpR2);
        jumpL2.mirrorHorizontally();

        fallL1 = new GreenfootImage(fallR1);
        fallL1.mirrorHorizontally();

        fallL2 = new GreenfootImage(fallR2);
        fallL2.mirrorHorizontally();
    }

    private void setupAnimationArrays() {
        // Create animation arrays for easy cycling
        runningRight = new GreenfootImage[]{runningR1, runningR2, runningR3, runningR4};
        runningLeft = new GreenfootImage[]{runningL1, runningL2, runningL3, runningL4};
        jumpingRight = new GreenfootImage[]{jumpR1, jumpR2};
        jumpingLeft = new GreenfootImage[]{jumpL1, jumpL2};
        fallingRight = new GreenfootImage[]{fallR1, fallR2};
        fallingLeft = new GreenfootImage[]{fallL1, fallL2};
    }

    private void handleInput() {
        handleMovement();
        handleAbility();
    }

    private void handleMovement(){
        // check if in air
        if(!onGround){
            // reset ground counter when in the air
            runningAnimCounter.reset();
            if(velocityY < 0){
                // reset falling counter when jumping
                fallingAnimCounter.reset();
                animateJumping();
            }else{
                // reset jumping counter when falling
                jumpingAnimCounter.reset();
                animateFalling();
            }

            // Moving in the air
            if (Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
                direction = false;
                velocityX = -MOVE_SPEED * 0.85; // Slightly reduced horizontal movement speed while in the air
            } else if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right")) {
                direction = true;
                velocityX = MOVE_SPEED * 0.85;
            } else {
                velocityX = 0;
            }
        }else{
            // Reset air counters when on ground
            jumpingAnimCounter.reset();
            fallingAnimCounter.reset();
            // Normal ground movement
            if (Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
                direction = false;
                velocityX = -MOVE_SPEED;
                animateRunning();
                soundManager.playSound("run");
            } else if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right")) {
                direction = true;
                velocityX = MOVE_SPEED;
                animateRunning();
                soundManager.playSound("run");
            } else {
                // Standing still
                velocityX = 0;
                frameCounter.reset();
                runningAnimCounter.reset();
                if(velocityY == 0){
                    if(!direction){
                        setImage(standingLeft);
                    }else{
                        setImage(standingRight);
                    }
                }
            }
        }

        // Jump
        if ((Greenfoot.isKeyDown("space") || Greenfoot.isKeyDown("w")) && onGround) {
            velocityY = JUMP_STRENGTH;
            onGround = false;
            // reset frames
            frameCounter.reset();
            jumpingAnimCounter.reset();

            // Play jump sound
            soundManager.playSound("jump");
        }

        // Fall faster
        if ((Greenfoot.isKeyDown("s") || Greenfoot.isKeyDown("down") && !onGround)){
            velocityY += GRAVITY;
        }
    }

    private void handleAbility(){
        if(abilityCooldownCounter.isZero()){
            if(Greenfoot.isKeyDown("h") || Greenfoot.isKeyDown("q") && currentMana >= 4 && currentHealth < maxHealth){
                isHealing = true;
            }
            if(Greenfoot.isKeyDown("j") || Greenfoot.isKeyDown("e")){
                basicAttack();
            }else if(Greenfoot.isKeyDown("k") && magicUnlocked){
                magicAttack();
            }
        }
    }

    private void basicAttack(){
        isAttacking = true;
        abilityCooldownCounter.set(BASIC_ATTACK_COOLDOWN);

        // Play sword sound
        soundManager.playSound("sword");

        // slash animation
        SlashAnimation slash;
        int slashWidth, slashHeight;
        if(!attackUpgraded){
            slash = new SlashAnimation(6, 2, false, false);
            slashWidth = 160;
            slashHeight = 80;
        }else{
            slash = new SlashAnimation(6, 2, false, true);
            slashWidth = 200;
            slashHeight = 100;
        }

        // changes depending on which direction the player is facing
        int slashOffsetX = direction ? 60: -60; 
        int slashOffsetY = 0; // same height as player

        // add to world
        GameWorld world = (GameWorld) getWorld();
        if(world != null){
            // World position
            int slashWorldX = worldX + slashOffsetX;
            int slashWorldY = worldY + slashOffsetY;
            // Screen position
            int slashScreenX = camera.worldToScreenX(slashWorldX);
            int slashScreenY = camera.worldToScreenY(slashWorldY);

            world.addObject(slash, slashScreenX, slashScreenY);

            // Flip image if facing left
            if(!direction){
                GreenfootImage slashImg = slash.getImage();
                slashImg.mirrorHorizontally();
                slash.setImage(slashImg);
            }

            checkSlashHit(slashWorldX, slashWorldY, slashWidth, slashHeight, world);
        }
    }

    private void magicAttack(){
        if(currentMana <= 0) return; // need Mana to use ability

        isAttacking = true;
        abilityCooldownCounter.set(MAGIC_ATTACK_COOLDOWN);

        // Play magic sound
        soundManager.playSound("magic");

        // Scale based on mana 
        double manaScale = Math.max(1.0, currentMana / 2.0);

        SlashAnimation magic = new SlashAnimation(3,5,true, false);

        // Scale the magic animation based on mana
        GreenfootImage magicImg = magic.getImage();
        int scaledWidth = (int)(120 * manaScale);
        int scaledHeight = (int)(100 * manaScale);
        magicImg.scale(scaledWidth, scaledHeight);
        magic.setImage(magicImg);

        // Scale offset and radius based on mana
        int baseOffset = 70;
        int magicOffsetX = direction ? (int)(baseOffset * manaScale) : -(int)(baseOffset * manaScale);
        int magicOffsetY = 0;

        int scaledRadius = (int)(MAGIC_ATTACK_RADIUS * manaScale);
        int scaledDamage = (int)(MAGIC_ATTACK_DAMAGE * manaScale);

        GameWorld world = (GameWorld) getWorld();
        if(world != null){
            // World position
            int magicWorldX = worldX + magicOffsetX;
            int magicWorldY = worldY + magicOffsetY;
            // Screen position
            int magicScreenX = camera.worldToScreenX(magicWorldX);
            int magicScreenY = camera.worldToScreenY(magicWorldY);

            world.addObject(magic, magicScreenX, magicScreenY);

            // Flip if facing left
            if(!direction){
                magicImg = magic.getImage();
                magicImg.mirrorHorizontally();
                magic.setImage(magicImg);
            }

            // spawn projectile
            checkRadiusHit(magicWorldX, magicWorldY, scaledRadius, scaledDamage, world);
        }

        currentMana = 0;
    }

    private void checkRadiusHit(int attackWorldX, int attackWorldY, int radius, int damage, World world){
        if(world == null) return;

        int EFFECTIVE_RADIUS = MAGIC_ATTACK_RADIUS + HITBOX_EXPANSION;
        // Get all potential targets
        ArrayList<Actor> targets = new ArrayList<>();
        targets.addAll(world.getObjects(BaseEnemy.class));
        targets.addAll(world.getObjects(Boss.class));
        targets.addAll(world.getObjects(Miniboss.class));

        for (Actor target : targets) {
            int targetX, targetY;

            // Handle ScrollingActor (Enemies) vs standard Actor (Boss)
            if (target instanceof ScrollingActor) {
                targetX = ((ScrollingActor) target).getWorldX();
                targetY = ((ScrollingActor) target).getWorldY();
            } else {
                targetX = target.getX();
                targetY = target.getY();
            }

            // Calculate distance between magic center and target center
            // Using Pythagorean theorem: a^2 + b^2 = c^2
            double dx = attackWorldX - targetX; 
            double dy = attackWorldY - targetY;
            double distance = Math.sqrt(dx * dx + dy * dy);

            // Check if the target is within the expanded radius
            if (distance <= EFFECTIVE_RADIUS) {
                if (target instanceof BaseEnemy) {
                    ((BaseEnemy) target).takeDamage(MAGIC_ATTACK_DAMAGE);
                } else if (target instanceof Boss) {
                    ((Boss) target).takeDamage(MAGIC_ATTACK_DAMAGE);
                } else if(target instanceof Miniboss){
                    ((Miniboss) target).takeDamage(MAGIC_ATTACK_DAMAGE);
                }
            }
        }
    }

    private void checkSlashHit(int attackWorldX, int attackWorldY, int width, int height, World world){
        if(world == null) return;

        // Define the boundaries of the slash hitbox
        int slashLeft = attackWorldX - (width / 2) - HITBOX_EXPANSION;
        int slashRight = attackWorldX + (width / 2) + HITBOX_EXPANSION;
        int slashTop = attackWorldY - (height / 2) - HITBOX_EXPANSION;
        int slashBottom = attackWorldY + (height / 2) + HITBOX_EXPANSION;

        // Create a list of all potential targets
        ArrayList<Actor> targets = new ArrayList<>();
        targets.addAll(world.getObjects(BaseEnemy.class));
        targets.addAll(world.getObjects(Boss.class));
        targets.addAll(world.getObjects(Miniboss.class));

        for (Actor target : targets) {
            int targetX, targetY;
            // Use world coordinates if available, otherwise use screen coordinates
            if (target instanceof ScrollingActor) {
                targetX = ((ScrollingActor) target).getWorldX();
                targetY = ((ScrollingActor) target).getWorldY();            
            }else{
                // Standard get X and Y for Boss
                targetX = target.getX();
                targetY = target.getY();
            }

            int tHalfW = target.getImage().getWidth() / 2;
            int tHalfH = target.getImage().getHeight() / 2;
            int targetLeft = targetX - tHalfW;
            int targetRight = targetX + tHalfW;
            int targetTop = targetY - tHalfH;
            int targetBottom = targetY + tHalfH;

            if (slashLeft < targetRight && slashRight > targetLeft && slashTop < targetBottom && slashBottom > targetTop) {

                // Calculate damage based on player upgrades
                int damage = attackUpgraded ? BASIC_ATTACK_DAMAGE * 2 : BASIC_ATTACK_DAMAGE;

                // Apply damage using type-specific methods
                if (target instanceof BaseEnemy) {
                    ((BaseEnemy) target).takeDamage(damage);
                } else if (target instanceof Boss) {
                    ((Boss) target).takeDamage(damage);
                } else if(target instanceof Miniboss){
                    ((Miniboss) target).takeDamage(MAGIC_ATTACK_DAMAGE);
                }

                soundManager.playSound("slash_enemy");

                // Increase mana
                currentMana = Math.min(currentMana + 1, MAX_MANA);
            }
        }
    }

    private void animateRunning(){
        runningAnimCounter.increment();

        // Change frame based on animation speed
        if (runningAnimCounter.isComplete()) {
            runningAnimCounter.reset();
            frameCounter.increment();

            // Loop back to first frame (4 total)
            if(frameCounter.greaterThan(3)){
                frameCounter.reset();
            }
        }

        // Set the appropriate frame based on direction
        if (direction) {
            setImage(runningRight[frameCounter.getCount()]);
        } else {
            setImage(runningLeft[frameCounter.getCount()]);
        }
    }

    private void animateJumping(){
        jumpingAnimCounter.increment();

        // Change frame based on animation speed
        if(jumpingAnimCounter.isComplete()) {
            jumpingAnimCounter.reset();
            frameCounter.increment();
        }
        // Loop back to first frame (4 total)
        if(frameCounter.greaterThan(1)){
            frameCounter.reset();
        }
        // Set frame based on direction
        if(direction){
            setImage(jumpingRight[frameCounter.getCount()]);
        }else{
            setImage(jumpingLeft[frameCounter.getCount()]);
        }
    }

    private void animateFalling(){
        fallingAnimCounter.increment();

        // Change frame based on animation speed
        if(fallingAnimCounter.isComplete()) {
            fallingAnimCounter.reset();
            frameCounter.increment();
        }

        // Loop back to first frame (2 total)
        if(frameCounter.greaterThan(1)){
            frameCounter.reset();
        }

        // Set frame based on direction
        if(direction){
            setImage(fallingRight[frameCounter.getCount()]);
        }else{
            setImage(fallingLeft[frameCounter.getCount()]);
        }
    }

    private void applyGravity() {
        velocityY += GRAVITY;
        if (velocityY > MAX_FALL_SPEED) {
            velocityY = MAX_FALL_SPEED;
        }
    }

    private void moveHorizontal() {
        // Try to move horizontally
        int targetX = (int)(worldX + velocityX);

        if (!isSolidAtPosition(targetX, worldY)) {
            // Path is clear, move freely
            worldX = targetX;
        } else {
            // Hit a wall, slide as close as possible
            int step = velocityX > 0 ? 1 : -1;
            while (!isSolidAtPosition(worldX + step, worldY)) {
                worldX += step;
            }
            velocityX = 0;
        }
    }

    private void moveVertical() {
        // Try to move vertically
        int targetY = (int)(worldY + velocityY);

        if (!isSolidAtPosition(worldX, targetY)) {
            // Path is clear, move freely
            worldY = targetY;
            onGround = false;
        } else {
            // Hit floor or ceiling, slide as close as possible
            int step = velocityY > 0 ? 1 : -1;
            while (!isSolidAtPosition(worldX, worldY + step)) {
                worldY += step;
            }

            // Check if we landed on ground
            if (velocityY > 0) {
                onGround = true;
            }
            velocityY = 0;
        }
    }

    public void takeDamage(int dmg){
        currentHealth = Math.max(0, currentHealth - dmg);
        soundManager.playSound("damage");
    }

    public void heal(int hp){
        currentHealth = Math.min(maxHealth, currentHealth + hp);
    }

    public void increaseMaxHealth(int hp){
        maxHealth = Math.min(maxHealth + hp, ABSOLUTE_MAX_HEALTH_POINTS);
        currentHealth = maxHealth;
    }

    /**
     * @author Paul
     */
    private void checkDoor(){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return;
        if (isDoorAtPosition(worldX, worldY)) {
            inDoor = true;
            if(getWorld() instanceof RoomOne){
                Greenfoot.setWorld(new RoomTwo("RoomOne"));
            }else if(getWorld() instanceof RoomTwo){
                Greenfoot.setWorld(new RoomThree("RoomTwo"));
            }
        } else {
            inDoor = false;
        }
    }

    private void checkInteractive(){
        if (isDoorAtPosition(worldX, worldY)) {
            inInteractive = true;

        } else {
            inInteractive = false;
        }
    }

    /**
     * Check if the player's hitbox at this position would collide with solid tiles
     * @author Paul assisted by Claude
     */ 
    private boolean isSolidAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;

        // Check all edges: corners + middle points for better collision
        return checkTileAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left corner
        checkTileAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right corner
        checkTileAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left corner
        checkTileAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right corner
        checkTileAt(posX, posY - halfHeight + 1) ||                  // Top-middle (HEAD)
        checkTileAt(posX, posY + halfHeight - 1) ||                  // Bottom-middle (FEET)
        checkTileAt(posX - halfWidth + 1, posY) ||                   // Left-middle
        checkTileAt(posX + halfWidth - 1, posY);                     // Right-middle
    }

    /**
     * @author Paul
     */
    private boolean isDoorAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;

        // Check four corners and center
        return checkDoorAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left
        checkDoorAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right
        checkDoorAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left
        checkDoorAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right
        checkDoorAt(posX, posY);                                      // Center
    }

    /**
     * @author Paul
     */
    private boolean isInteractiveAtPosition(int posX, int posY) {
        int halfWidth = getImage().getWidth() / 2;
        int halfHeight = getImage().getHeight() / 2;

        // Check four corners and center
        return checkInteractiveAt(posX - halfWidth + 1, posY - halfHeight + 1) ||  // Top-left
        checkInteractiveAt(posX + halfWidth - 1, posY - halfHeight + 1) ||  // Top-right
        checkInteractiveAt(posX - halfWidth + 1, posY + halfHeight - 1) ||  // Bottom-left
        checkInteractiveAt(posX + halfWidth - 1, posY + halfHeight - 1) ||  // Bottom-right
        checkInteractiveAt(posX, posY);                                      // Center
    }

    /**
     *  Check if a specific world coordinate contains a solid tile
     *  @author Paul
     */
    private boolean checkTileAt(int worldX, int worldY) {
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        // Type 1 = walls, Type 2 = platforms, Type 3 = doors
        return tileType == 1 || tileType == 2 ;
    }

    /**
     * @author Paul
     */
    private boolean checkDoorAt(int worldX, int worldY){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        return tileType == 3 ;
    }

    /**
     * @author Paul
     */
    private boolean checkInteractiveAt(int worldX, int worldY){
        GameWorld world = (GameWorld) getWorld();
        if (world == null) return false;

        int tileX = world.worldToTileX(worldX);
        int tileY = world.worldToTileY(worldY);

        int tileType = world.mapGrid.getTileAt(tileX, tileY);

        return tileType == 5 ;
    }
    // Setters
    public void setHealth(int health){
        currentHealth = health;
    }

    public void setMana(int mana){
        currentMana = mana;
    }

    public void upgradeBasicAttack(){
        attackUpgraded = true;
    }

    public void unlockMagicAttack(){
        magicUnlocked = true;
    }

    public void addToCurrency(int num)
    {
        currency += num;
    }

    // Getters
    public boolean isAttackUpgraded(){
        return attackUpgraded;
    }

    public static boolean isMagicUnlocked(){
        return magicUnlocked;
    }

    public boolean isOnGround() {
        return onGround;
    }

    public int getHealth(){
        return currentHealth;
    }

    public int getMaxHealth(){
        return maxHealth;
    }

    public int getAbsMaxHealth(){
        return ABSOLUTE_MAX_HEALTH_POINTS;
    }

    public int getMana(){
        return currentMana;
    }

    public boolean isInDoor(){
        return inDoor;
    }

    public boolean isInInteractive(){
        return inInteractive;
    }

    public double getVelocityX() {
        return velocityX;
    }

    public double getVelocityY() {
        return velocityY;
    }

    public int getAbilityCooldown(){
        return abilityCooldownCounter.getCount();
    }

    public int getItemCount(int item){
        return itemCount[item];
    }

    public int getCurrency()
    {
        return currency;
    }
}